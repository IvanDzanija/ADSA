from __future__ import annotations
from collections import deque


class Node:
    """
    A class representing a single node.
    """

    def __init__(self, symbol: str, probability: int, left=None, right=None):
        self.symbol = symbol
        self.probability = probability
        self.left = left
        self.right = right

    def is_leaf(self):
        return self.left is None and self.right is None


class Huffman:
    """
    A class representing a Huffman compression algorithm.
    """

    def __init__(self):
        self.root = None
        self.coding_table = dict()

    def build(self, symbols: list, probabilities: list):
        """
        Class method to generate Huffman tree based on sorted input of symbols and probabilites.
        """
if len(leafs) == 1:
            # Create a dummy parent so the single node has a code (e.g., "0")
            node = leafs.popleft()
            self.root = Node("", node.probability, left=node)
        n = len(symbols)
        leafs = deque(Node(symbols[i], probabilities[i]) for i in range(n))  # red queue
        internal_nodes = deque()  # blue queue

        while len(leafs) + len(internal_nodes) > 1:
            min1, min2 = self._pop_two_smallest(leafs, internal_nodes)

            combined_prob = min1.probability + min2.probability
            combined_node = Node("", combined_prob, min1, min2)

            internal_nodes.append(combined_node)
        self.root = internal_nodes.popleft()

        # We have to actually create a coding table.
        self.coding_table.clear()
        # BFS on generated tree
        q = deque()
        q.append((self.root, ""))
        while q:
            node, coding_word = q.popleft()
            # assert node is not None
            if node.symbol:
                self.coding_table[node.symbol] = coding_word
                continue
            if node.left:
                q.append((node.left, coding_word + "0"))
            if node.right:
                q.append((node.right, coding_word + "1"))

        return self.root

    def encode(self, input: str):
        """
        Converts a string of text into a binary string using the generated tree.
        """

        if not input:
            return ""

        if self.root is None:
            self._build_from_raw(input)

        result = ""

        result = []
        for char in input:
            if char in self.coding_table:
                result.append(self.coding_table[char])
            else:
                raise ValueError(
                    f"Character '{char}' not found in coding table. Rebuild tree with all characters."
                )

        return "".join(result)

    def decode(self, input: str):
        """
        Converts a binary string back into text using the tree.
        """

        if not input or not self.root:
            return ""

        result = []
        current_node = self.root

        for bit in input:
            if bit == "0":
                current_node = current_node.left
            elif bit == "1":
                current_node = current_node.right

            if current_node.is_leaf():
                result.append(current_node.symbol)
                current_node = self.root

        return "".join(result)

    def _build_from_raw(self, input: str):
        freq = {}
        for ch in input:
            freq[ch] = freq.get(ch, 0) + 1

        symbols = sorted(freq.keys())
        freqs = [freq[ch] for ch in symbols]
        self.build(symbols, freqs)

    def _pop_two_smallest(self, dq1: deque, dq2: deque):
        """
        A helper function to get the 2 smallest values in 2 deques
        """

        def pop_smallest():
            if not dq1:
                return dq2.popleft()
            if not dq2:
                return dq1.popleft()
            if dq1[0].probability <= dq2[0].probability:
                return dq1.popleft()
            else:
                return dq2.popleft()

        first = pop_smallest()
        second = pop_smallest()

        return first, second
